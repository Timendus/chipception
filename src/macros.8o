:macro make16 REGa REGb WORD {
    :calc hi { ( WORD >> 8 ) & 0xFF }
    :calc lo { WORD & 0xFF }
    REGa := hi
    REGb := lo
}

:macro set16 LOCATION WORD {
    make16 v0 v1 WORD
    i := LOCATION
    save v1
}

:macro set8 LOCATION BYTE {
    i := LOCATION
    vF := BYTE
    save vF
}

# Add (REGa, REGb) as one 16-bit number to the index register (destructive to REGa)
:macro add-to-i REGa REGb {
    loop
        while REGa != 0
        vF := 0xFF
        i += vF
        vF := 1
        i += vF
        REGa -= 1
    again
    i += REGb
}

# Some long-lived registers and their meanings
:alias cycles v8
:alias vfQuirk v9
:alias shiftQuirk vA
:alias memQuirk vB
:alias jumpQuirk vC
:alias dispQuirk vD
:alias clipQuirk vE

# Show the registers in the memory monitor
:monitor v8 "cycles: %1i\nvfQuirk: %1i\nshiftQuirk: %1i\nmemQuirk: %1i\njumpQuirk: %1i\ndispQuirk: %1i\nclipQuirk: %1i\n"

# A few constants giving meaning to magic values
:const STATE_STOPPED 0
:const STATE_RUNNING 1
:const STATE_WAITING_FOR_INTERRUPT 2
:const STATE_INTERRUPT_TRIGGERED 3

:const DISPLAY_LORES 0
:const DISPLAY_HIRES 1
