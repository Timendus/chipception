:macro make16 REGa REGb WORD {
    :calc hi { ( WORD >> 8 ) & 0xFF }
    :calc lo { WORD & 0xFF }
    REGa := hi
    REGb := lo
}

:macro set16 LOCATION WORD {
    make16 v0 v1 WORD
    i := LOCATION
    save v1
}

:macro set8 LOCATION BYTE {
    i := LOCATION
    vF := BYTE
    save vF - vF
}

# Add (REGa, REGb) as one 16-bit number to the index register (destructive to REGa)
:macro add-to-i REGa REGb {
    loop
        while REGa != 0
        vF := 0xFF
        i += vF
        vF := 1
        i += vF
        REGa -= 1
    again
    i += REGb
}

# A few constants giving meaning to magic values

:const STATE_STOPPED 0
:const STATE_RUNNING 1
:const STATE_WAITING_FOR_INTERRUPT 2
:const STATE_INTERRUPT_TRIGGERED 3

:const DISPLAY_LORES 0
:const DISPLAY_HIRES 1

:const VF_QUIRK    0b10000000
:const SHIFT_QUIRK 0b01000000
:const MEM_QUIRK   0b00100000
:const JUMP_QUIRK  0b00010000
:const DISP_QUIRK  0b00001000
:const CLIP_QUIRK  0b00000100

:calc CHIP8     { VF_QUIRK + MEM_QUIRK + CLIP_QUIRK }
:calc VIP       { VF_QUIRK + MEM_QUIRK + DISP_QUIRK + CLIP_QUIRK }
:calc SUPERCHIP { SHIFT_QUIRK + JUMP_QUIRK + CLIP_QUIRK }

:macro get-quirk REG QUIRK {
    i := quirks
    load REG - REG
    vF := QUIRK
    REG &= vF
}
:macro set-quirk QUIRK {
    i := quirks
    load v0 - v0
    vF := QUIRK
    v0 |= vF
    save v0 - v0
}
:macro reset-quirk QUIRK {
    :calc INVERTED { ~ QUIRK }
    i := quirks
    load v0 - v0
    vF := INVERTED
    v0 &= vF
    save v0 - v0
}
:macro set-quirks QUIRKS {
    i := quirks
    vF := QUIRKS
    save vF - vF
}
