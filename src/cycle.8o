: run-cycle
    # Load and increase PC
    point-to PC
    load v0 - v1
    v2 := v0
    v3 := v1
    vF := 2
    v1 += vF
    v0 += vF
    save v0 - v1

    # Load opcode from memory
    point-to RAM
    add-to-i v2 v3
    load v1

    # Split up first byte
    v2 := v0
    vF := 0xF0
    v2 &= vF
    v3 := v0
    vF := 0x0F
    v3 &= vF

    if v2 == 0x00 then jump range-00

    # Jump to NNN
    if v2 == 0x10 begin
        v0 := v3
        point-to PC
        save v1
        return
    end

    # Subroutine call to NNN
    if v2 == 0x20 begin
        # Load and increase stack pointer
        point-to SP
        load v0 - v0
        v2 := v0
        v0 += 2
        save v0
        # Load old PC and write call destination
        point-to PC
        load v4 - v5
        v0 := v3
        save v1
        point-to STACK
        i += v2
        save v4 - v5
        return
    end

    # Skip next opcode if register X == NN
    if v2 == 0x30 begin
        point-to REGISTERS
        i += v3
        load v0
        if v0 == v1 then jump skip-next-opcode
        return
    end

    # Skip next opcode if register X != NN
    if v2 == 0x40 begin
        point-to REGISTERS
        i += v3
        load v0
        if v0 != v1 then jump skip-next-opcode
        return
    end

    # Skip next opcode if registers are equal
    if v2 == 0x50 begin
        point-to REGISTERS
        i += v3
        load v0
        point-to REGISTERS
        v1 >>= v1  v1 >>= v1
        v1 >>= v1  v1 >>= v1
        i += v1
        load v1 - v1
        if v0 == v1 then jump skip-next-opcode
        return
    end

    # Set register X to NN
    if v2 == 0x60 begin
        point-to REGISTERS
        i += v3
        save v1 - v1
        return
    end

    # Add NN to register X
    if v2 == 0x70 begin
        point-to REGISTERS
        i += v3
        load v0 - v0
        v0 += v1
        save v0
        return
    end

    if v2 == 0x80 then jump do-maths

    # Skip next opcode if registers are not equal
    if v2 == 0x90 begin
        point-to REGISTERS
        i += v3
        load v0
        point-to REGISTERS
        v1 >>= v1  v1 >>= v1
        v1 >>= v1  v1 >>= v1
        i += v1
        load v1 - v1
        if v0 != v1 then jump skip-next-opcode
        return
    end

    # Set i to NNN
    if v2 == 0xA0 begin
        v0 := v3
        point-to INDEX
        save v1
        return
    end

    # Jump to NNN + v0
    if v2 == 0xB0 begin
        get-quirk v0 JUMP_QUIRK
        point-to REGISTERS
        if v0 != 0 then i += v3
        load v2 - v2
        v0 := v3
        v1 += v2
        v0 += vF
        point-to PC
        save v1
        return
    end
    
    # Get random number, masked by NN into register X
    if v2 == 0xC0 begin
        point-to REGISTERS
        i += v3
        v0 := random 0xFF
        v0 &= v1
        save v0
        return
    end

    if v2 == 0xD0 then jump draw-sprite

    # Skip next opcode if key is pressed / not pressed
    if v2 == 0xE0 begin
        point-to REGISTERS
        i += v3
        load v0
        if v1 == 0x9E begin
            if v0 key then jump skip-next-opcode
            return
        end
        if v1 == 0xA1 begin
            if v0 -key then jump skip-next-opcode
            return
        end
        # We should never get here
        :breakpoint unknown-opcode-E0-v1
        loop again
    end

    if v2 == 0xF0 then jump range-F0

    # We should never get here
    :breakpoint unknown-opcode
    loop again

: skip-next-opcode
    point-to PC
    load v0 - v1
    vF := 2
    v1 += vF
    v0 += vF
    save v0 - v1
    return

: step-back-one-opcode
    point-to PC
    load v0 - v1
    vF := 2
    v1 -= vF
    if vF == 0 then v0 -= 1
    save v0 - v1
    return

: range-00
    v2 := v1
    vF := 0xF0
    v2 &= vF

    # Scroll the display down N pixels
    if v2 == 0xC0 begin
        v1 >>= v1
        v1 >>= v1
        v1 >>= v1
        v1 >>= v1
        vF := 0xC0
        v1 |= vF
        i := scroll-down-smc
        save v1 - v1
        0x00
        : scroll-down-smc
        0x00
        return
    end

    # Clear screen
    if v1 == 0xE0 begin
        i := long window-mode
        load v0
        if v0 == MODE_FULLSCREEN begin
            clear
        else
            point-to DISPLAY_BUFFER
            v0 := 0
            v1 := 0
            loop
                save v0
                v1 += 1
                if v1 != 0 then
            again
        end
        return
    end

    # Return from subroutine
    if v1 == 0xEE begin
        # Load and decrease stack pointer
        point-to SP
        load v0 - v0
        v0 -= 2
        save v0
        # Restore PC
        point-to STACK
        i += v0
        load v1
        point-to PC
        save v1
        return
    end

    # Scroll the display right 4 pixels
    if v1 == 0xFB begin
        scroll-right
        return
    end

    # Scroll the display left 4 pixels
    if v1 == 0xFC begin
        scroll-left
        return
    end

    # Exit the interpreter, back to the menu
    if v1 == 0xFD begin
        point-to RUNNING
        v0 := STATE_STOPPED
        save v0
        jump step-back-one-opcode
    end

    # Set the display mode to lores
    if v1 == 0xFE begin
        point-to DISPLAY_MODE
        v0 := DISPLAY_LORES
        save v0
        lores
        return
    end

    # Set the display mode to hires
    if v1 == 0xFF begin
        point-to DISPLAY_MODE
        v0 := DISPLAY_HIRES
        save v0
        hires
        return
    end

    # We should never get here
    :breakpoint unknown-opcode-00-v1
    loop again

: do-maths
    v2 := v1
    vF := 0x0F
    v2 &= vF
    v1 >>= v1
    v1 >>= v1
    v1 >>= v1
    v1 >>= v1

    # Pre-load register Y
    point-to REGISTERS
    i += v1
    load v4 - v4

    # Pre-load register X
    point-to REGISTERS
    i += v3
    load v0 - v0

    # Copy value of register Y into register X
    if v2 == 0x00 begin
        save v4 - v4
        return
    end

    # Register X |= register Y
    if v2 == 0x01 begin
        v0 |= v4
        save v0
        get-quirk v0 VF_QUIRK
        if v0 != 0 begin
            vF := 0
            jump save-flag
        end
        return
    end

    # Register X &= register Y
    if v2 == 0x02 begin
        v0 &= v4
        save v0
        get-quirk v0 VF_QUIRK
        if v0 != 0 begin
            vF := 0
            jump save-flag
        end
        return
    end

    # Register X ^= register Y
    if v2 == 0x03 begin
        v0 ^= v4
        save v0
        get-quirk v0 VF_QUIRK
        if v0 != 0 begin
            vF := 0
            jump save-flag
        end
        return
    end

    # Register X += register Y
    if v2 == 0x04 begin
        v0 += v4
        save v0
        jump save-flag
    end

    # Register X -= register Y
    if v2 == 0x05 begin
        v0 -= v4
        save v0
        jump save-flag
    end

    # Register X = register Y >> 1
    if v2 == 0x06 begin
        get-quirk v1 SHIFT_QUIRK
        if v1 != 0 then v4 := v0
        v4 >>= v4
        v0 := vF
        point-to REGISTERS
        i += v3
        save v4 - v4
        vF := v0
        jump save-flag
    end

    # Register X = register Y - register X
    if v2 == 0x07 begin
        v4 -= v0
        save v4 - v4
        jump save-flag
    end

    # Register X = register Y << 1
    if v2 == 0x0E begin
        get-quirk v1 SHIFT_QUIRK
        if v1 != 0 then v4 := v0
        v4 <<= v4
        v0 := vF
        point-to REGISTERS
        i += v3
        save v4 - v4
        vF := v0
        jump save-flag
    end

    # We should never get here
    :breakpoint unknown-opcode-80-v1-v2
    loop again

: save-flag
    v0 := vF
    :calc VF_REGISTER { REGISTERS + 0xF }
    point-to VF_REGISTER
    save v0
    return

: draw-sprite
    get-quirk v0 DISP_QUIRK
    if v0 != 0 begin
        point-to RUNNING
        load v0 - v0
        if v0 == STATE_WAITING_FOR_INTERRUPT then
            jump step-back-one-opcode
        if v0 == STATE_RUNNING begin
            v0 := STATE_WAITING_FOR_INTERRUPT
            save v0
            jump step-back-one-opcode
        end
        if v0 == STATE_INTERRUPT_TRIGGERED begin
            v0 := STATE_RUNNING
            save v0
        end
    end

    # Load value from first register
    point-to REGISTERS
    i += v3
    load v0

    # Load value from second register
    v2 := v1
    v1 >>= v1
    v1 >>= v1
    v1 >>= v1
    v1 >>= v1
    point-to REGISTERS
    i += v1
    load v1 - v1
    point-to DISPLAY_MODE
    load v3 - v3
    if v3 == DISPLAY_LORES then v4 := 31
    if v3 == DISPLAY_HIRES then v4 := 63
    v1 &= v4
    v4 += 1

    # Set draw height
    vF := 0x0F
    v2 &= vF
    v7 := 1
    if v2 == 0 begin
        v2 := 16
        v7 := 2
    end
    get-quirk v3 CLIP_QUIRK
    if v3 != 0 begin
        # if v1 > (height - v2):
        #     v2 = height - v1
        v3 := v4
        v3 -= v2
        if v1 > v3 begin
            v2 := v4
            v2 -= v1
        end
    end
    v6 := v2 # Save height for later
    vF := 0x10
    v2 |= vF
    i := draw-sprite-smc1
    save v2 - v2

    # Set i register
    i := long current-machine-ptr
    load v4 - v5
    vF := RAM
    v5 += vF
    v4 += vF
    point-to INDEX
    load v2 - v3
    v5 += v3
    v4 += vF
    v4 += v2
    get-quirk v2 CLIP_QUIRK
    if v2 != 0 begin
        # if v0 > (width - spriteWidth):
        #     spriteWidth = width - v0
        point-to DISPLAY_MODE
        load v2 - v2
        if v2 == DISPLAY_LORES then v3 := 63
        if v2 == DISPLAY_HIRES then v3 := 127
        v0 &= v3 # Mask X coordinate
        v3 += 1
        v2 := v3
        v2 -= 8
        if v6 == 16 then v2 -= 8
        if v0 > v2 begin
            v2 := v3
            v2 -= v0
            # v2 is new width, now make a mask
            vF := 8
            if v6 == 16 then vF := 16
            v2 =- vF
            v3 := 0xFF
            v8 := 0xFF
            loop
                v8 <<= v8
                v3 <<= v3
                if vF != 0 then v8 += 1
                v2 -= 1
                if v2 != 0 then
            again
            v2 := 0
            loop
                i := draw-sprite-smc3
                save v4 - v5
                0xF0 0x00   # i := long ...
                : draw-sprite-smc3
                0x00 0x00   # sprite address
                # i points to start of sprite
                i += v2
                if v6 == 16 begin
                    i += v2
                    load vA - vB
                    vA &= v8
                    vB &= v3  # Mask out overflowing bits / pixels
                    i := long draw-sprite-store
                    i += v2
                    i += v2
                    save vA - vB
                else
                    load vA - vA
                    vA &= v3  # Mask out overflowing bits / pixels
                    i := long draw-sprite-store
                    i += v2
                    save vA - vA
                end
                v2 += 1
                if v2 != v6 then
            again
            :alias unpack-hi v4
            :alias unpack-lo v5
            :unpack long draw-sprite-store
        end
    end
    i := draw-sprite-smc2
    save v4 - v5

    i := long window-mode
    load vF - vF
    if vF != MODE_FULLSCREEN begin
        v2 := v0
        v3 := v1
        vF := DISPLAY_BUFFER
        unpack-pointer
        v0 := v4
        v1 := v5
        v9 := 64        # TODO: hires
        vC := 32
        blit-sprite
    else
        # Actually do the thing
        0xF0 0x00       # i := long ...
        : draw-sprite-smc2
        0x00 0x00       # sprite address
        :next draw-sprite-smc1
        sprite v0 v1 8  # 8 overwritten by actual height
    end
    jump save-flag

:segment data

: draw-sprite-store
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0

:segment code

: range-F0
    # Pre-load i to point to register X
    point-to REGISTERS
    i += v3

    # Load delay timer into register X
    if v1 == 0x07 begin
        point-to DELAY_TIMER
        load v0
        point-to REGISTERS
        i += v3
        save v0
        return
    end

    # Wait for key and return in register X
    if v1 == 0x0A begin
        v0 := 0
        loop
            if v0 key begin
                save v0
                return
            end
            v0 += 1
            if v0 != 0x10 then
        again
        jump step-back-one-opcode
    end

    # Write register X into delay timer
    if v1 == 0x15 begin
        load v0
        point-to DELAY_TIMER
        save v0
        return
    end

    # Write register X to sound timer
    if v1 == 0x18 begin
        load v0
        point-to SOUND_TIMER
        save v0
        return
    end
    
    # Add register X to i
    if v1 == 0x1E begin
        load v2 - v2
        point-to INDEX
        load v0 - v1
        v1 += v2
        v0 += vF
        save v1
        return
    end

    # Point i to font sprite for value in register X
    if v1 == 0x29 begin
        load v0
        v1 := v0
        v1 <<= v1
        v1 <<= v1
        v1 += v0
        v0 := 0
        point-to INDEX
        save v1
        return
    end

    # Point i to big font sprite for value in register X
    if v1 == 0x30 begin
        load v0
        v1 := v0
        v1 <<= v1
        v1 <<= v1
        v1 <<= v1
        v1 += v0
        v1 += v0
        v1 += 80
        v0 := 0
        point-to INDEX
        save v1
        return
    end

    # BCD encode register X to i
    if v1 == 0x33 begin
        load v2 - v2
        point-to INDEX
        load v1
        point-to RAM
        add-to-i v0 v1
        bcd v2
        return
    end

    # Store registers to memory
    if v1 == 0x55 begin
        v2 := 0
        loop
            point-to REGISTERS
            i += v2
            load v4 - v4
            point-to INDEX
            load v1
            point-to RAM
            add-to-i v0 v1
            i += v2
            save v4 - v4
            v2 += 1
            if v2 <= v3 then
        again
        get-quirk v0 MEM_QUIRK
        if v0 != 0 begin
            point-to INDEX
            load v0 - v1
            v3 += 1
            v1 += v3
            v0 += vF
            save v1
        end
        return
    end

    # Load registers from memory
    if v1 == 0x65 begin
        v2 := 0
        loop
            point-to INDEX
            load v1
            point-to RAM
            add-to-i v0 v1
            i += v2
            load v1 - v1
            point-to REGISTERS
            i += v2
            save v1 - v1
            v2 += 1
            if v2 <= v3 then
        again
        get-quirk v0 MEM_QUIRK
        if v0 != 0 begin
            point-to INDEX
            load v0 - v1
            v3 += 1
            v1 += v3
            v0 += vF
            save v1
        end
        return
    end

    # Store registers to userflags
    if v1 == 0x75 begin
        v2 := 0
        loop
            point-to REGISTERS
            i += v2
            load v4 - v4
            point-to USERFLAGS
            i += v2
            save v4 - v4
            v2 += 1
            if v2 <= v3 then
        again
        return
    end

    # Load registers from userflags
    if v1 == 0x85 begin
        v2 := 0
        loop
            point-to USERFLAGS
            i += v2
            load v1 - v1
            point-to REGISTERS
            i += v2
            save v1 - v1
            v2 += 1
            if v2 <= v3 then
        again
        return
    end

    # We should never get here
    :breakpoint unknown-opcode-f0-v1
    loop again

