:include "macros.8o"

: main

    # Initialize machines table (should be dynamic at some point)
    :alias unpack-hi v0
    :alias unpack-lo v1
    :unpack long free-memory
    i := long machines
    save v1
    make16 v2 v3 MACHINE_SIZE
    v1 += v3
    v0 += vF
    v0 += v2
    save v1
    v1 += v3
    v0 += vF
    v0 += v2
    save v1
    v1 += v3
    v0 += vF
    v0 += v2
    save v1

    # Make sure we are running in hires ourselves and we sound friendly
    hires
    clear
    i := beep-pattern
    audio
    v0 := 70
    pitch := v0

    loop
        init 0  0  0 SUPERCHIP rom-pong
        init 1 64  0 SUPERCHIP rom-space-invaders
        init 2  0 32 CHIP8     rom-christmas
        init 3 64 32 CHIP8     rom-sierpinski
        run-interpreters
    again

# Run until program exits or magic key combo is pressed
: run-interpreters
    loop
        v0 := 1
        delay := v0

        # Run each CPU for the requested number of cycles
        current-machine := 0
        loop
            select-machine
            point-to RUNNING
            load v0
            if v0 != STATE_STOPPED begin
                point-to CYCLES_PER_FRAME
                load v0
                point-to CYCLE
                save v0
                loop
                    run-cycle
                    point-to CYCLE
                    load v0 - v0
                    v0 -= 1
                    save v0
                    if v0 != 0 then
                again
            end
            current-machine += 1
            if current-machine != NUM_MACHINES then
        again

        # Wait to sync up with reality
        loop
            v0 := delay
            if v0 != 0 then
        again

        # Check for magic key combo
        v0 := 0
        if v0 key begin
            v0 := 0xA
            if v0 key then return
        end

        # Run all the timer stuff for each CPU
        current-machine := 0
        vD := 0
        loop
            select-machine
            # Decrement timers and play sound
            point-to DELAY_TIMER
            load v0 - v0
            if v0 != 0 then v0 -= 1
            save v0
            point-to SOUND_TIMER
            load v0 - v0
            if v0 != 0 begin
                v0 -= 1
                vD := 1
            end
            save v0

            # Check if we're waiting for dispQuirk
            point-to RUNNING
            load v0 - v0
            if v0 == STATE_WAITING_FOR_INTERRUPT then
                v0 := STATE_INTERRUPT_TRIGGERED
            save v0

            current-machine += 1
            if current-machine != NUM_MACHINES then
        again
        buzzer := vD
    again

# Lazily reset the interpreter
: reset
    set16 PC               0x200
    set8  SP               0
    set8  DISPLAY_MODE     DISPLAY_LORES
    set8  RUNNING          STATE_RUNNING
    set8  CYCLES_PER_FRAME 30
    return

# (v1, v2) point to program data, copy it into RAM at 0x200
: load-program
    make16 v3 v4 0
    loop
        i := load-program-smc
        save v1 - v2
        0xF0 0x00
        : load-program-smc
        0x00 0x00
        # i == program address
        load-program-add
        # i == byte within program
        load v0
        point-to RAM
        v3 += 2
        load-program-add
        v3 -= 2
        save v0

        # Increase index
        vF := 1
        v4 += vF
        v3 += vF

        # Are we done? (Just fill RAM, whatever)
        if v3 != 0x0E then
    again
    return

# Add (v3, v4) as one 16-bit number to the index register
: load-program-add
    v5 := v3
    add-to-i v5 v4
    return

# (v1, v2) point to font data, copy it into RAM at 0x000
: load-font
    v3 := 0
    loop
        i := load-font-smc
        save v1 - v2
        0xF0 0x00   # i := long ...
        : load-font-smc
        0x00 0x00
        i += v3
        load v0
        point-to RAM
        i += v3
        save v0
        v3 += 1
        if v3 != 180 then
    again
    return

: pointer-to
    i := long current-machine-ptr
    load vA - vB
    i := load-pointer-smc
    save vA - vB
    0xF0 0x00   # i := long ...
    : load-pointer-smc
    0x00 0x00
    i += vF
    return

: select-machine
    i := machines
    i += current-machine
    i += current-machine
    load v1
    i := current-machine-ptr
    save v1
    return

:segment data

: machines
    0 0
    0 0
    0 0
    0 0

:monitor machines "0x%2x 0x%2x"

: current-machine-ptr
    :pointer free-memory

:monitor current-machine-ptr "0x%2x"
:monitor current-machine 1

: beep-pattern
    0xFF 0x00 0xFF 0x00 0xFF 0x00 0xFF 0x00 0xFF 0x00 0xFF 0x00 0xFF 0x00 0xFF 0x00

:include "cycle.8o"
:include "fonts.8o"
:include "roms.8o"

: free-memory
    # Starts here
